#!/usr/bin/env python3
import sys

header_start = """
 * THIS FILE IS AUTOMATICALLY GENERATED. ANY DIRECT MODIFICATION TO THIS FILE IS
 * STRONGLY DISCOURAGED. YOUR CHANGES TO THIS FILE MAY BE LOST UPON RE-GENERATION.
 */

#ifndef RAPTOR_DBW_CAN__CANID_ENUM_HPP_
#define RAPTOR_DBW_CAN__CANID_ENUM_HPP_

namespace raptor_dbw_can
{
#undef BUILD_ASSERT

/** \\brief Enumeration of CAN message IDs */
enum ListMessageIDs
{

"""

header_end = """
};

}       // namespace raptor_dbw_can

#endif  // RAPTOR_DBW_CAN__CANID_ENUM_HPP_

"""

def generate_c_canid_enum_header(dbcfile:str, enum_header_file:str):
    with open(dbcfile, 'r') as f:
        lines = f.readlines()
        f.close()
    can_ids = dict()
    for line in lines:
        if not line.startswith('BO_ '):
            continue
        # we have found a canid entry
        terms = line.split(' ')
        # convert from decimal to hex, use upper-case letters, and remove '0x'
        canid_hex = hex(int(terms[1])).upper()[2:]
        # remove colon at the end
        canid_label = terms[2][:-1]
        can_ids.update({canid_label: canid_hex})
    with open(enum_header_file, 'w') as f:
        f.writelines([
            "/* Enumeration of CAN IDs as provided in the CAN DBC file:\n",
            " * " + dbcfile + "\n",
            " *\n",
            " * To re-generate this file, run from the package directory:\n",
            " * python ./scripts/dbc_to_c_canid_enum.py " + dbcfile + " " +\
                    enum_header_file + "\n",
            " *",
            header_start
        ])
        # sort using can_id
        sorted_dict_items = sorted(can_ids.items(), key=lambda x: x[1])
        for key, value in sorted_dict_items:
            f.write('ID_' + key.upper() + ' = 0x' + value + ',\n')
        f.write(header_end)
        f.close()

if __name__ == "__main__":
    generate_c_canid_enum_header(sys.argv[1], sys.argv[2])
